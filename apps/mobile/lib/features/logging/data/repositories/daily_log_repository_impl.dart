import 'package:supabase_flutter/supabase_flutter.dart';

import '../../domain/entities/daily_log.dart';
import '../../domain/repositories/daily_log_repository.dart';
import '../datasources/daily_log_remote_datasource.dart';
import '../models/daily_log_model.dart';

/// Implementation of DailyLogRepository
class DailyLogRepositoryImpl implements DailyLogRepository {
  const DailyLogRepositoryImpl(this._remoteDataSource);

  final DailyLogRemoteDataSource _remoteDataSource;

  String? get _currentPatientId {
    final session = Supabase.instance.client.auth.currentSession;
    if (session == null) return null;
    // Patient ID is stored in user metadata, not the auth user ID
    final metadata = session.user.userMetadata;
    return metadata?['patient_id'] as String?;
  }

  @override
  Future<DailyLogResult<List<DailyLog>>> getLogs({
    DateTime? date,
    DateTime? startDate,
    DateTime? endDate,
    LogType? logType,
    int? limit,
    int? offset,
  }) async {
    try {
      final patientId = _currentPatientId;
      print('[DailyLogRepo] getLogs called. patientId: $patientId');
      if (patientId == null) {
        print('[DailyLogRepo] No patientId found in user metadata');
        return const DailyLogFailure('Not authenticated');
      }

      final logs = await _remoteDataSource.getLogs(
        patientId: patientId,
        date: date,
        startDate: startDate,
        endDate: endDate,
        logType: logType,
        limit: limit,
        offset: offset,
      );

      print('[DailyLogRepo] Fetched ${logs.length} logs');
      return DailyLogSuccess(logs);
    } catch (e) {
      print('[DailyLogRepo] Error fetching logs: $e');
      return DailyLogFailure('Failed to get logs: $e');
    }
  }

  @override
  Future<DailyLogResult<DailyLog>> getLog(String id) async {
    try {
      final log = await _remoteDataSource.getLog(id);
      if (log == null) {
        return const DailyLogFailure('Log not found');
      }
      return DailyLogSuccess(log);
    } catch (e) {
      return DailyLogFailure('Failed to get log: $e');
    }
  }

  @override
  Future<DailyLogResult<List<DailyLog>>> getLogsForDate(DateTime date) async {
    try {
      final patientId = _currentPatientId;
      if (patientId == null) {
        return const DailyLogFailure('Not authenticated');
      }

      final logs = await _remoteDataSource.getLogsForDate(
        patientId: patientId,
        date: date,
      );

      return DailyLogSuccess(logs);
    } catch (e) {
      return DailyLogFailure('Failed to get logs for date: $e');
    }
  }

  @override
  Future<DailyLogResult<DailyLog>> addLog({
    required DateTime logDate,
    required LogType logType,
    required String title,
    String? description,
    Map<String, dynamic>? metadata,
    DateTime? loggedAt,
  }) async {
    try {
      final patientId = _currentPatientId;
      if (patientId == null) {
        return const DailyLogFailure('Not authenticated');
      }

      final model = DailyLogModel(
        id: '', // Will be generated by Supabase
        patientId: patientId,
        logDate: logDate,
        logType: logType,
        title: title,
        description: description,
        metadata: metadata,
        loggedAt: loggedAt ?? DateTime.now(),
      );

      final result = await _remoteDataSource.addLog(model);
      return DailyLogSuccess(result);
    } catch (e) {
      return DailyLogFailure('Failed to add log: $e');
    }
  }

  @override
  Future<DailyLogResult<DailyLog>> updateLog(DailyLog log) async {
    try {
      final model = DailyLogModel.fromEntity(log);
      final result = await _remoteDataSource.updateLog(model);
      return DailyLogSuccess(result);
    } catch (e) {
      return DailyLogFailure('Failed to update log: $e');
    }
  }

  @override
  Future<DailyLogResult<void>> deleteLog(String id) async {
    try {
      await _remoteDataSource.deleteLog(id);
      return const DailyLogSuccess(null);
    } catch (e) {
      return DailyLogFailure('Failed to delete log: $e');
    }
  }
}

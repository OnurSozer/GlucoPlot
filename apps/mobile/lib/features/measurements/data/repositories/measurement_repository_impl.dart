import 'package:supabase_flutter/supabase_flutter.dart';

import '../../domain/entities/measurement.dart';
import '../../domain/repositories/measurement_repository.dart';
import '../datasources/measurement_remote_datasource.dart';
import '../models/measurement_model.dart';

/// Implementation of MeasurementRepository
class MeasurementRepositoryImpl implements MeasurementRepository {
  MeasurementRepositoryImpl(this._remoteDataSource);

  final MeasurementRemoteDataSource _remoteDataSource;

  // Cache the patient ID to avoid repeated lookups
  String? _cachedPatientId;

  Future<String?> _getCurrentPatientId() async {
    // Return cached value if available
    if (_cachedPatientId != null) return _cachedPatientId;

    final session = Supabase.instance.client.auth.currentSession;
    if (session == null) return null;

    // Try to get from user metadata first
    final metadata = session.user.userMetadata;
    var patientId = metadata?['patient_id'] as String?;

    // If not in metadata, look up from patients table by auth_user_id
    if (patientId == null) {
      final authUserId = session.user.id;
      final result = await Supabase.instance.client
          .from('patients')
          .select('id')
          .eq('auth_user_id', authUserId)
          .maybeSingle();

      if (result != null) {
        patientId = result['id'] as String?;
      }
    }

    _cachedPatientId = patientId;
    return patientId;
  }

  @override
  Future<MeasurementResult<List<Measurement>>> getMeasurements({
    MeasurementType? type,
    DateTime? startDate,
    DateTime? endDate,
    int? limit,
    int? offset,
  }) async {
    try {
      final patientId = await _getCurrentPatientId();
      if (patientId == null) {
        return const MeasurementFailure('Not authenticated');
      }

      final measurements = await _remoteDataSource.getMeasurements(
        patientId: patientId,
        type: type,
        startDate: startDate,
        endDate: endDate,
        limit: limit,
        offset: offset,
      );

      return MeasurementSuccess(measurements);
    } catch (e) {
      return MeasurementFailure('Failed to get measurements: $e');
    }
  }

  @override
  Future<MeasurementResult<Measurement>> getMeasurement(String id) async {
    try {
      final measurement = await _remoteDataSource.getMeasurement(id);
      if (measurement == null) {
        return const MeasurementFailure('Measurement not found');
      }
      return MeasurementSuccess(measurement);
    } catch (e) {
      return MeasurementFailure('Failed to get measurement: $e');
    }
  }

  @override
  Future<MeasurementResult<Map<MeasurementType, Measurement>>> getLatestMeasurements() async {
    try {
      final patientId = await _getCurrentPatientId();
      if (patientId == null) {
        return const MeasurementFailure('Not authenticated');
      }

      final measurements = await _remoteDataSource.getLatestMeasurements(patientId);
      return MeasurementSuccess(measurements);
    } catch (e) {
      return MeasurementFailure('Failed to get latest measurements: $e');
    }
  }

  @override
  Future<MeasurementResult<Measurement>> addMeasurement({
    required MeasurementType type,
    required double value,
    double? secondaryValue,
    String? unit,
    required DateTime measuredAt,
    MealTiming? mealTiming,
    String? notes,
    bool isAutoSaved = false,
  }) async {
    try {
      final patientId = await _getCurrentPatientId();
      if (patientId == null) {
        return const MeasurementFailure('Not authenticated');
      }

      final model = MeasurementModel(
        id: '', // Will be generated by database
        patientId: patientId,
        type: type,
        value: value,
        secondaryValue: secondaryValue,
        unit: unit,
        measuredAt: measuredAt,
        mealTiming: mealTiming,
        notes: notes,
        isAutoSaved: isAutoSaved,
      );

      final result = await _remoteDataSource.addMeasurement(model);
      return MeasurementSuccess(result);
    } catch (e) {
      return MeasurementFailure('Failed to add measurement: $e');
    }
  }

  @override
  Future<MeasurementResult<Measurement>> updateMeasurement(Measurement measurement) async {
    try {
      final model = MeasurementModel.fromEntity(measurement);
      final result = await _remoteDataSource.updateMeasurement(model);
      return MeasurementSuccess(result);
    } catch (e) {
      return MeasurementFailure('Failed to update measurement: $e');
    }
  }

  @override
  Future<MeasurementResult<void>> deleteMeasurement(String id) async {
    try {
      await _remoteDataSource.deleteMeasurement(id);
      return const MeasurementSuccess(null);
    } catch (e) {
      return MeasurementFailure('Failed to delete measurement: $e');
    }
  }

  @override
  Future<MeasurementResult<MeasurementStats>> getStats({
    required MeasurementType type,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final patientId = await _getCurrentPatientId();
      if (patientId == null) {
        return const MeasurementFailure('Not authenticated');
      }

      final measurements = await _remoteDataSource.getMeasurements(
        patientId: patientId,
        type: type,
        startDate: startDate,
        endDate: endDate,
      );

      if (measurements.isEmpty) {
        return MeasurementSuccess(MeasurementStats(
          type: type,
          count: 0,
        ));
      }

      final values = measurements.map((m) => m.value).toList();
      final avg = values.reduce((a, b) => a + b) / values.length;
      final minVal = values.reduce((a, b) => a < b ? a : b);
      final maxVal = values.reduce((a, b) => a > b ? a : b);

      // Calculate trend (compare first half to second half)
      MeasurementTrend? trend;
      if (measurements.length >= 4) {
        final midpoint = measurements.length ~/ 2;
        final firstHalfAvg = values.sublist(0, midpoint).reduce((a, b) => a + b) / midpoint;
        final secondHalfAvg = values.sublist(midpoint).reduce((a, b) => a + b) / (values.length - midpoint);

        if (secondHalfAvg > firstHalfAvg * 1.05) {
          trend = MeasurementTrend.increasing;
        } else if (secondHalfAvg < firstHalfAvg * 0.95) {
          trend = MeasurementTrend.decreasing;
        } else {
          trend = MeasurementTrend.stable;
        }
      }

      return MeasurementSuccess(MeasurementStats(
        type: type,
        count: measurements.length,
        average: avg,
        min: minVal,
        max: maxVal,
        trend: trend,
      ));
    } catch (e) {
      return MeasurementFailure('Failed to get stats: $e');
    }
  }
}
